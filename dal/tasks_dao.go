package dal

// This code was generated by a tool. Don't modify it manually.
// http://sqldalmaker.sourceforge.net

type TasksDao struct {
	Ds *DataStore
}

// (C)RUD: tasks
// Generated values are passed to DTO.

func (dao *TasksDao) CreateTask(p *Task) (err error) {
	sql := `insert into tasks (g_id, t_priority, t_date, t_subject, t_comments) values (?, ?, ?, ?, ?)`
	res, err := dao.Ds.Insert(sql, "t_id", p.GId, p.TPriority, p.TDate, p.TSubject, p.TComments)
	if err != nil {
		return
	}
	dao.Ds.Assign(&p.TId, res)
	return
}

// C(R)UD: tasks

func (dao *TasksDao) ReadTask(tId int64) (res Task, err error) {
	sql := `select * from tasks where t_id=?`
	rd, err := dao.Ds.QueryRow(sql, tId)
	if err != nil {
		return
	}
	res = Task{}
	dao.Ds.Assign(&res.TId, rd["t_id"] /* t(t_id) <- t(t_id) */)
	dao.Ds.Assign(&res.GId, rd["g_id"] /* t(g_id) <- t(g_id) */)
	dao.Ds.Assign(&res.TPriority, rd["t_priority"] /* t(t_priority) <- t(t_priority) */)
	dao.Ds.Assign(&res.TDate, rd["t_date"] /* t(t_date) <- t(t_date) */)
	dao.Ds.Assign(&res.TSubject, rd["t_subject"] /* t(t_subject) <- t(t_subject) */)
	dao.Ds.Assign(&res.TComments, rd["t_comments"] /* t(t_comments) <- t(t_comments) */)
	return
}

// CR(U)D: tasks
// Returns the number of affected rows or -1 on error.

func (dao *TasksDao) UpdateTask(p *Task) (res int64, err error) {
	sql := `update tasks set g_id=?, t_priority=?, t_date=?, t_subject=?, t_comments=? where t_id=?`
	res, err = dao.Ds.Exec(sql, p.GId, p.TPriority, p.TDate, p.TSubject, p.TComments, p.TId)
	return
}

// CRU(D): tasks
// Returns the number of affected rows or -1 on error.

func (dao *TasksDao) DeleteTask(tId int64) (res int64, err error) {
	sql := `delete from tasks where t_id=?`
	res, err = dao.Ds.Exec(sql, tId)
	return
}

func (dao *TasksDao) GetGroupTasks(gId int64) (res []*Task, err error) {
	sql := `select * from tasks where g_id =? 
		order by t_id`
	onDto := func(rd map[string]interface{}) {
		obj := Task{}
		dao.Ds.Assign(&obj.TId, rd["t_id"] /* t(t_id) <- q(t_id) */)
		dao.Ds.Assign(&obj.GId, rd["g_id"] /* t(g_id) <- q(g_id) */)
		dao.Ds.Assign(&obj.TPriority, rd["t_priority"] /* t(t_priority) <- q(t_priority) */)
		dao.Ds.Assign(&obj.TDate, rd["t_date"] /* t(t_date) <- q(t_date) */)
		dao.Ds.Assign(&obj.TSubject, rd["t_subject"] /* t(t_subject) <- q(t_subject) */)
		dao.Ds.Assign(&obj.TComments, rd["t_comments"] /* t(t_comments) <- q(t_comments) */)
		res = append(res, &obj)
	}
	err = dao.Ds.QueryAllRows(sql, onDto, gId)
	return
}

// Returns the number of affected rows or -1 on error.

func (dao *TasksDao) DeleteGroupTasks(gId string) (res int64, err error) {
	sql := `delete from tasks where g_id=?`
	res, err = dao.Ds.Exec(sql, gId)
	return
}

func (dao *TasksDao) GetCount() (res int64, err error) {
	sql := `select count(*) from tasks`
	r, err := dao.Ds.Query(sql)
	if err != nil {
		return
	}
	var v int64
	dao.Ds.Assign(&v, r)
	res = v
	return
}
