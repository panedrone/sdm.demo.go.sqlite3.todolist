package main

// This code was generated by a tool. Don't modify it manually.
// http://sqldalmaker.sourceforge.net

type GroupsDao struct {
    ds *DataStore
}

// (C)RUD: groups
// Generated values are passed to DTO.
// Returns the number of affected rows or -1 on error.

func (dao *GroupsDao) createGroup(p *Group) {
    sql := "insert into groups (g_name) values (?)"
    res := dao.ds.insert(sql, p.GName)
    p.GId = res
}

// C(R)UD: groups

func (dao *GroupsDao) readGroup(GId int64) Group {
    sql := "select * from groups where g_id=?"
    rd := dao.ds.queryRow(sql, GId)
    obj := Group{}
    obj.GId = rd["g_id"].(int64)
    obj.GName = rd["g_name"].(string)
    return obj
}

// CR(U)D: groups
// Returns the number of affected rows or -1 on error.

func (dao *GroupsDao) updateGroup(p *Group) int64 {
    sql := "update groups set g_name=? where g_id=?"
    return dao.ds.execDML(sql, p.GName, p.GId)
}

// CRU(D): groups
// Returns the number of affected rows or -1 on error.

func (dao *GroupsDao) deleteGroup(GId int64) int64 {
    sql := "delete from groups where g_id=?"
    return dao.ds.execDML(sql, GId);
}

func (dao *GroupsDao) getGroups() []Group {
    sql := "select g.*, " + 
        "\n (select count(*) from tasks where g_id=g.g_id) as tasks_count" + 
        "\n from groups g"
    var res []Group
    onDto := func(rd map[string]interface{}) {
        obj := Group{}
        obj.GId = rd["g_id"].(int64)
        obj.GName = rd["g_name"].(string)
        obj.TasksCount = rd["tasks_count"].(int64)
        res = append(res, obj)
    }
    dao.ds.queryAllRows(sql, onDto)
    return res
}
